///*05-树9 Huffman Codes （30 分）
//In 1953, David A. Huffman published his paper "A Method for the Construction of Minimum-Redundancy Codes", and hence printed his name in the history of computer science. As a professor who gives the final exam problem on Huffman codes, I am encountering a big problem: the Huffman codes are NOT unique. For example, given a string "aaaxuaxz", we can observe that the frequencies of the characters 'a', 'x', 'u' and 'z' are 4, 2, 1 and 1, respectively. We may either encode the symbols as {'a'=0, 'x'=10, 'u'=110, 'z'=111}, or in another way as {'a'=1, 'x'=01, 'u'=001, 'z'=000}, both compress the string into 14 bits. Another set of code can be given as {'a'=0, 'x'=11, 'u'=100, 'z'=101}, but {'a'=0, 'x'=01, 'u'=011, 'z'=001} is NOT correct since "aaaxuaxz" and "aazuaxax" can both be decoded from the code 00001011001001. The students are submitting all kinds of codes, and I need a computer program to help me determine which ones are correct and which ones are not.
//
//Input Specification:
//Each input file contains one test case. For each case, the first line gives an integer N (2≤N≤63), then followed by a line that contains all the N distinct characters and their frequencies in the following format:
//
//c[1] f[1] c[2] f[2] ... c[N] f[N]
//where c[i] is a character chosen from {'0' - '9', 'a' - 'z', 'A' - 'Z', '_'}, and f[i] is the frequency of c[i] and is an integer no more than 1000. The next line gives a positive integer M (≤1000), then followed by M student submissions. Each student submission consists of N lines, each in the format:
//
//c[i] code[i]
//where c[i] is the i-th character and code[i] is an non-empty string of no more than 63 '0's and '1's.
//
//Output Specification:
//For each test case, print in each line either "Yes" if the student's submission is correct, or "No" if not.
//
//Note: The optimal solution is not necessarily generated by Huffman algorithm. Any prefix code with code length being optimal is considered correct.
//
//Sample Input:
//7
//A 1 B 1 C 1 D 3 E 3 F 6 G 6
//4
//A 00000
//B 00001
//C 0001
//D 001
//E 01
//F 10
//G 11
//A 01010
//B 01011
//C 0100
//D 011
//E 10
//F 11
//G 00
//A 000
//B 001
//C 010
//D 011
//E 100
//F 101
//G 110
//A 00000
//B 00001
//C 0001
//D 001
//E 00
//F 10
//G 11
//Sample Output:
//Yes
//Yes
//No
//No
//heap struct

#include <stdio.h>
#include <limits.h>
#include <string.h>
#include <stdlib.h>
#define ET HuffmanTree
#define ERROR NULL
#define MAXSIZE 63

typedef struct TreeNode * HuffmanTree;
struct TreeNode{
    int Weight;
    char Data;
    HuffmanTree Left, Right;
};

typedef struct HeapRecord * MinHeap;
struct HeapRecord{
	ET * Elements;//array of HuffmanTrees
	int Size;
	int Capacity;
};

MinHeap Create();
int IsFull(MinHeap H);
int IsEmpty(MinHeap H);
void Insert(MinHeap H, ET X);
ET DeleteMin(MinHeap H);
ET Top(MinHeap H);
HuffmanTree Huffman(MinHeap H);
MinHeap ReadFreq(int N);
void Print(MinHeap H);
char Symbol[MAXSIZE];
int Freq[200];
//-----------------


MinHeap Create(){
	//printf("s\n");
	MinHeap H = (MinHeap) malloc( sizeof(struct HeapRecord));
	H->Size = 0;
	H->Capacity = MAXSIZE;
	H->Elements = (ET *) malloc((MAXSIZE+1) * sizeof(ET));
	H->Elements[0]= (ET) malloc(sizeof(struct TreeNode));//sentienel
	H->Elements[0]->Weight = INT_MIN;
	return H;
}
int IsFull(MinHeap H){
	return (H->Size == H->Capacity)	;
}
int IsEmpty(MinHeap H){
	return (H->Size  == 0)	;
}

void Insert(MinHeap H, ET X){
	if(IsFull(H)) {
		printf("最小堆已满\n");
		return;
	}
	int i =  ++ H->Size;
	for( ;H->Elements[i/2]->Weight > X->Weight ; i/=2){
		H->Elements[i] = H->Elements[i/2];//percolate up
	}
	H->Elements[i] = X;
}
ET DeleteMin(MinHeap H){
	if(IsEmpty(H)) return ERROR;
	ET Min = H->Elements[1];
	//printf("deleting %c\n",Min->Data );
	int i = 1;
	ET tmp = H->Elements[H->Size--];//last element need to move up and percolate down
	int Parent, Child;
	for( Parent = 1; Parent * 2 <= H->Size; Parent = Child){
		Child = Parent * 2;
		if ((Child!= H->Size)&&(H->Elements[Child]->Weight > H->Elements[Child+1]->Weight)) 
			Child ++;//child point to the child with smaller value
		if ( tmp->Weight <= H->Elements[Child]->Weight) break;
		else H->Elements[Parent] = H->Elements[Child];
	}
	H->Elements[Parent] = tmp;
	return Min;
}
ET Top(MinHeap H){
	if(!IsEmpty(H)) return H->Elements[1];
	else return ERROR;
}
//construct a huffman code

//construct HuffmanTree from a Heap of singleton H-Trees
HuffmanTree Huffman(MinHeap H){
    int i; 
    HuffmanTree T;
    while( H->Size >=2){
    	//printf("%d:\n",H->Size); 
        T = (HuffmanTree) malloc(sizeof(struct TreeNode));
                T->Data  = '0'+H->Size;
        T->Left  = DeleteMin(H);
        T->Right = DeleteMin(H);

        T->Weight = T->Left->Weight + T->Right->Weight;
        Insert(H, T);
    }
    T = DeleteMin(H);
    return T;
}
//read frequencies into MinHeap
MinHeap ReadFreq(int N){
	char X;
	int Weight;
	MinHeap H = Create();
	HuffmanTree T;
	int i;
	for( i = 0; i <N; i++){
		if(i==N-1) scanf("%c %d\n",&X,&Weight);
		else scanf("%c %d ",&X,&Weight);
		Symbol[i] = X;
		Freq[X-'_'] = Weight;
		//printf("%c %d ",X,Weight);
		T = malloc(sizeof(struct TreeNode));
		T->Left = NULL;
		T->Right = NULL;
		T->Data = X;
		T->Weight = Weight;
		Insert(H,T);
	}
	return H;
}

void PrintHeap(MinHeap H){
	int N = H->Size;
	//printf("%d",N);
	int i = 1;
	int Weight;
	char X;
	while(N--) {
		Weight = H->Elements[i]->Weight;
		X = H->Elements[i]->Data;
		printf("%c %d ",X,Weight);
		i++;
	}
	printf("\n");
}
void PrintHTIn(HuffmanTree T,char  code[],int lv){
	if(T){
		code[lv]='0';
		PrintHTIn(T->Left,code,lv+1);
		//if(!(T->Left||T->Right))printf("%c",T->Data);
		printf("%c",T->Data);
		code[lv]='1';
		PrintHTIn(T->Right,code,lv+1);
	}	
}



void PrintHTPre(HuffmanTree T,char  code[],int lv){
	if(T){
		code[lv]='0';
		//if(!(T->Left||T->Right))printf("%c",T->Data);
		printf("%c",T->Data);
		PrintHTPre(T->Left,code,lv+1);
		
		code[lv]='1';
		PrintHTPre(T->Right,code,lv+1);
	}
}

void ComputPWL(HuffmanTree T,int lv, int * ptrPWL){
	if(T){
		ComputPWL(T->Left,lv+1,ptrPWL);
		if((!T->Left)&&(!T->Right)){
			//printf("%d %c %s\t",lv,T->Data,code2);
			*ptrPWL += lv* Freq[T->Data-'_'];
		}
		//printf("%c",T->Data);
		ComputPWL(T->Right,lv+1,ptrPWL);
	}	
}
//is prefix code? brutal force
typedef struct PTreeNode * PTree;
struct PTreeNode{
	int IsHold;//if this node represent a code
	PTree Left,Right;
};
PTree CreatPTree(){
	PTree T = (PTree) malloc(sizeof(struct PTreeNode));
	T->Left = T->Right = NULL;
	T->IsHold = 0; 
}

void DestoryPTree(PTree T){
	if(T){
		DestoryPTree(T->Left);
		DestoryPTree(T->Right);
		free(T);
		T = NULL;
	}
	return;
}

int CheckPrefix2(char  **code, int N){
	int i,j,Len;
	PTree T = CreatPTree();
	PTree tmp;
	int flag = 1;
	for(i=0;i<N;i++){
		Len = strlen(code[i]);
		tmp = T;
		for(j=0;j<Len;j++){
			if(code[i][j]=='0'){
				if(!tmp->Left) tmp->Left = CreatPTree();
				else if(tmp->Left -> IsHold == 1 || j == Len - 1){
					flag = 0;
					return flag;
					}
				tmp = tmp->Left;
			}
			else{
				if(!tmp->Right) tmp->Right = CreatPTree();			
				else if(tmp->Right -> IsHold == 1 || j == Len - 1){
					flag = 0;
					return flag;
					}
				tmp = tmp->Right;
			}
		}
		tmp->IsHold = 1;
	}
	DestoryPTree(T);
	return flag;
}


int CheckPrefix(char  **code, int N){
	int flag  = 1;
	int flag2 = 1;
	int i,j,l;
	for(i=0;i<N;i++){
		if(!flag) continue;
		else{
			for(j=0;j<N;j++){
				//printf("%d %d %s %s %d %d\n",i,j,code[i],code[j],strlen(code[i]),strlen(code[j]));
				if(j==i||strlen(code[j])<=strlen(code[i])||!flag) {
				//printf("No check\n");
				continue;
				}
				else{
					flag2 = 0;
					for(l=0;l<strlen(code[i]);l++)
						{flag2 += (code[j][l]==code[i][l]);
						}	
					//printf("flag2: %d %d %s %s %d\n",i,j,code[i],code[j],flag2);
					if(flag2==strlen(code[i]))flag = 0;
				}
			}		
		}
	}
	return flag;
}
//is optimal?

int main(){
	freopen("5.9.txt","r",stdin);
	int N;
	scanf("%d\n",&N);
	//printf(stderr,"s\n");
	MinHeap H = ReadFreq(N);
	//PrintHeap(H);
	HuffmanTree T = Huffman(H);
//	printf("In order:\n");
//	PrintHTIn(T,code,0);
//	printf("\n");
//	printf("Pre order:\n");
//	PrintHTPre(T,code,0);
//	printf("\n");
//	printf("In order with code:\n");
	int PWL = 0;
	ComputPWL(T,0,&PWL);
	printf("%d",PWL);
//	//printf("\n");
//	int i;
////	for(i=0;i<N;i++){
////		printf("%c %d ;",Symbol[i],Freq[Symbol[i]-'_']);
////	} 
//	//printf("\n");
//	//printf("PWL is %d \n",PWL);
//	int KTimes;
//	scanf("%d\n",&KTimes);
//	int PWL_k;
//	char InputSymbol[N];
//	char ** Code = (char **)malloc(N*sizeof(char *));
//	int k;
//	for(k=0;k<KTimes;k++){
//		PWL_k=0;
//		for(i=0;i<N;i++){
//		Code[i] = (char *)malloc(MAXSIZE*sizeof(char ));
//		scanf("%c %s\n",&InputSymbol[i],Code[i]);
//		//printf("%c %s %d\n",InputSymbol[i],Code[i],strlen(Code[i]));
//		PWL_k += Freq[InputSymbol[i]-'_']* strlen(Code[i]); 
//		}
//		//printf("%d: %d\n",k,PWL_k);
//		if(PWL_k==PWL){
//			if (CheckPrefix2(Code,N)) printf("Yes\n");
//			else printf("No\n");
//		}
//		else printf("No\n");
//	}
//	
//	//read codes , check = PWL and is prefix;
//	
	
	return 0;
} 
